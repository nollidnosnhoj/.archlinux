#!/usr/bin/env bun

// Based on https://github.com/antholeole/nixconfig/blob/main/programs/zx/fuzzel-omnibar.mts
import { $ } from "bun";

const priorityBrowsers = ["zen-twilight", "helium"];
const hasFuzzel = Boolean(Bun.which("fuzzel"));
const hasNiri = Boolean(Bun.which("niri"));

const findBrowser = async () => {
    const windows = (await $`niri msg --json windows`).json();
    
    for (const window of windows) {
        if (priorityBrowsers.includes(window.app_id)) return window.id;
    }

    return undefined;
};

const getSearchInput = async () => {
	const args = process.argv.slice(2);

	if (args.length > 0) {
		if (args.length > 1 && ["!arch", "!gh"].includes(args[0])) {
			throw new Error('Wrap "!arch ..." or "!gh ..." in a single quoted argument.');
		}

		return args.join(" ").trim();
	}

	if (hasFuzzel) {
		return (await $`fuzzel --lines 0 --prompt "search: " --dmenu`).text().trimEnd();
	}

	throw new Error("fuzzel is unavailable and no input argument was provided.");
};

const openUrl = async (url) => {
	if (process.platform === "linux") {
		await $`xdg-open ${url}`;
		return;
	}

	if (process.platform === "darwin") {
		await $`open ${url}`;
		return;
	}

	throw new Error(`Unsupported OS: ${process.platform}. Only linux and macOS are supported.`);
};

const onSearch = async () => {
	const searchInput = await getSearchInput();

	let url;
	if (searchInput.startsWith("!arch")) {
		const searchTerm = searchInput.replace("!arch", "").trim();
		url = `https://wiki.archlinux.org/index.php?&search=${encodeURIComponent(searchTerm)}`
	} else if (searchInput.startsWith("!gh")) {
		let remainingFuzzelInput = searchInput.replace("!gh ", "").trim();
		url = `https://github.com/search?q=${encodeURIComponent(`"${remainingFuzzelInput}"`)}&type=code`;
	} else {
		url = `https://www.google.com/search?q=${encodeURIComponent(searchInput)}`;
	}

	const actions = [openUrl(url)];

	if (hasNiri) {
		const browserId = await findBrowser();

		if (browserId !== undefined) {
			actions.push($`niri msg action focus-window --id=${browserId}`);
		}
	}

	await Promise.all(actions);
};

onSearch().catch((error) => {
  console.error(error);
  process.exit(1);
});
